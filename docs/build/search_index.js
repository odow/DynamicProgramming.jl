var documenterSearchIndex = {"docs":
[{"location":"solve.html#Solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"solve.html","page":"Solve","title":"Solve","text":"The solve function takes as input the initalised SDPModel object, as well as two keyword arguments.","category":"page"},{"location":"solve.html","page":"Solve","title":"Solve","text":"The realisation must be one of WaitAndSee, HereAndNow or ExpectedValue.","category":"page"},{"location":"solve.html","page":"Solve","title":"Solve","text":"The WaitAndSee model observes the noise before choosing the optimal control. The HereAndNow model chooses the best control before observing the noise. The ExpectedValue model substitutes the noise for the expected value of each independent noise.","category":"page"},{"location":"solve.html","page":"Solve","title":"Solve","text":"The riskmeasure is a nested λE[x] + (1-λ)CVaRᵦ[x].","category":"page"},{"location":"solve.html","page":"Solve","title":"Solve","text":"solve(m::SDPModel,\n    realisation=WaitAndSee,\n    riskmeasure=NestedCVaR(beta=0.5, lambda=0.5)\n)","category":"page"},{"location":"model_formulation.html#Initialise-Model","page":"Model Formulation","title":"Initialise Model","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"A SDP model is stored in the SDPModel type. A SDPModel can be intialised using the following SDPModel() do ... end block structure:","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"m = SDPModel(\n        stages = 1.   # Int\n        sense  = :Min # Symbol (:Min or :Max)\n    ) do sp, t\n\n        ... problem definition ...\n\nend","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"sp can be given any name but refers to the stage problem. t can also be given any name, but refers to an index that runs from 1 to T where T is the number of stages.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"Inside the SDPModel definition, we define our subproblems. We first need to add some state variables, some control (or action) variables, and some noise (or stochastic) variables.","category":"page"},{"location":"model_formulation.html#Initialise-Variables","page":"Model Formulation","title":"Initialise Variables","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"States can be added with the following macro:","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"@addstates!(sp, begin\n    x = linspace(0, 1, 10)\nend)","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"This creates a state variable x that is discretised into the set linspace(0, 1, 10). Note that currently, all state dimensions get converted into Float64 representations. The discretisation should be any type that can be converted to a Vector{Float64} type.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"Controls can be added with the @addcontrols! macro that has similar syntax. However there is less restriction on the type. The discretisation should just be an iterable subtype of AbstractVector.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"Noise (or stochastic variables) can be added with the @addnoises! macro:","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"@addnoises!(sp, begin\n    u = DiscreteDistribution([1,2,3], [0.5, 0.25, 0.25])\n    v = 1:10\nend)","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"In contrast to the other two macros, there is a slight subtlety. The discretisations can either be subtypes of AbstractVector (in which case their realisations are assumed to be uniformly sampled), or a DiscreteDistribution.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"The WeighedDist constructor is DiscreteDistribution(values::AbstractVector, probability::AbstractVector). This realisations values are sampled with probability probability.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"If more than one noise is defined, then the multiple noises are assumed to be independent.","category":"page"},{"location":"model_formulation.html#Dynamics","page":"Model Formulation","title":"Dynamics","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"You must provide a function that takes four inputs.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"function foo(states_out, states, controls, noises)\nend","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"However, we prefer the anonymous function syntax:","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"dynamics!(sp, (y, x, u, w) -> (\n        ... definitions ...\n    )\n)","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"This anonymous function must take the current state x,  a control u and a noise w and update the new state y.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"You can refer to model variables using the [] indexing operator. For example, if we defined a state variable quantity, we could refer it as x[quantity].","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"By thinking about variable scopes it is possible to encapsulate all the necessary data into this syntax.","category":"page"},{"location":"model_formulation.html#Stage-Objective","page":"Model Formulation","title":"Stage Objective","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"The stage objective function takes as input vectors for the initial state, control and noise. It should return a single Float64 value corresponding to the cost (or profit) accrued in the current stage.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"stageobjective!(sp, (x, u, w) -> (\n        ... definitions ...\n    )\n)","category":"page"},{"location":"model_formulation.html#Terminal-Objective","page":"Model Formulation","title":"Terminal Objective","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"The terminal objective function takes as input a vector of the final state at the end of the finite time horizon. It returns a single Float64 value corresponding to the cost (or profit) of ending in that state.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"terminalobjective!(sp, (x) -> (\n        ... definitions ...\n    )\n)","category":"page"},{"location":"model_formulation.html#Constraints","page":"Model Formulation","title":"Constraints","text":"","category":"section"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"The constraints function takes as input vectors for the initial state, control and noise. It should return a single Bool value indicating if the state, control, noise combination is feasible. Typically this can be implemented by a chained series of boolean comparisons.","category":"page"},{"location":"model_formulation.html","page":"Model Formulation","title":"Model Formulation","text":"constraints!(sp, (x, u, w) -> (\n        ... definitions ...\n    )\n)","category":"page"},{"location":"visualisation.html#Visualise","page":"Visualise","title":"Visualise","text":"","category":"section"},{"location":"visualisation.html","page":"Visualise","title":"Visualise","text":"It is possible to create an interactive visualisation of the simulated policy with the @visualise macro. The following keywords should be wrapped with parentheses.","category":"page"},{"location":"visualisation.html","page":"Visualise","title":"Visualise","text":"\"cumulative\"  = false Plot the cumulation of the variable over stages\n\"title\"       = \"\" Plot title\n\"xlabel\"      = \"Stages\" Label for x axis\n\"ylabel\"      = \"\" Label for y axis\n\"interpolate\" = \"linear\" D3.js interpolation method to use. See the D3 wiki for more.","category":"page"},{"location":"visualisation.html","page":"Visualise","title":"Visualise","text":"The following example gives an example of possible syntax:","category":"page"},{"location":"visualisation.html","page":"Visualise","title":"Visualise","text":"@visualise(results, stage, replication, begin\nresults[:Current][stage][replication],  (title=\"Accumulated Profit\", ylabel=\"Accumulated Profit (\\$)\", cumulative=true)\nresults[:x][stage][replication],    (title=\"Value of a State\", ylabel=\"Level\")\nresults[:u][stage][replication],    (title=\"Value of a Control\")\nresults[:w][stage][replication],    (title=\"Value of a Noise\", interpolate=\"step\")\nend)","category":"page"},{"location":"simulate.html#Simulate","page":"Simulate","title":"Simulate","text":"","category":"section"},{"location":"simulate.html","page":"Simulate","title":"Simulate","text":"Once a SDPModel has been solved, it is possible to simulate the performance of the policy using the function simulate(m::SDPModel, N::Int; kwargs...). m is the solved SDPModel to be simulated. N is the number of realisations to perform. Initial values for the state variables are given via the keyword arguments.","category":"page"},{"location":"simulate.html","page":"Simulate","title":"Simulate","text":"For example:","category":"page"},{"location":"simulate.html","page":"Simulate","title":"Simulate","text":"results = simulate(m,\n    500,\n    contracts  = 0,\n    price      = 4.5,\n    production = 0.\n)","category":"page"},{"location":"index.html#DynamicProgramming.jl","page":"Home","title":"DynamicProgramming.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Julia package for discrete stochastic dynamic programming.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package is not yet registered. You can install it by typing","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Pkg.clone(\"https://github.com/odow/DynamicProgramming.jl.git\")","category":"page"}]
}
